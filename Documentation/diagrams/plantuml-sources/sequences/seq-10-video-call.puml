@startuml Video Call WebRTC Flow
!define PRIMARY_COLOR #E3F2FD
!define SECONDARY_COLOR #FFF3E0
!define SUCCESS_COLOR #E8F5E9
!define ERROR_COLOR #FFEBEE

skinparam sequenceMessageAlign center
skinparam responseMessageBelowArrow true
skinparam backgroundColor #FFFFFF
skinparam defaultFontName Arial
skinparam defaultFontSize 10

title Video Call with WebRTC (UC021)

actor "User A\n(Caller)" as userA #E3F2FD
actor "User B\n(Callee)" as userB #E3F2FD
participant "Frontend A" as frontA #FFF3E0
participant "Frontend B" as frontB #FFF3E0
participant "Socket.IO\nSignaling" as signal #FFF9C4
participant "Backend" as backend #E8F5E9
participant "STUN/TURN\nServers" as stun #F3E5F5
database "Database" as db #F3E5F5

== Initiate Call ==

userA -> frontA: Click "Start Video Call"\nin team workspace
activate frontA

frontA -> backend: POST /api/meetings\n{team_id, type: 'video'}
activate backend

backend -> db: INSERT INTO meetings\n(team_id, started_by,\nstarted_at, status: 'active')\nRETURNING id
activate db
db --> backend: meeting_id
deactivate db

backend --> frontA: 201 Created\n{meeting_id}
deactivate backend

frontA -> frontA: Request media permissions:\nnavigator.mediaDevices\n.getUserMedia({video, audio})

alt Permissions Granted
    frontA -> frontA: Local media stream\nobtained
    
    frontA --> userA: Show local video preview
    
    frontA -> signal: emit("call_initiated",\n{meeting_id, team_id,\ncaller_id: userA_id})
    activate signal
    
    signal -> signal: Broadcast to all\nteam members in room
    
    signal --> frontB: emit("incoming_call",\n{meeting_id, caller: userA})
    deactivate signal
    
else Permissions Denied
    frontA --> userA: "Camera/microphone\naccess denied"
    frontA -> frontA: Stop call initiation
end

deactivate frontA

== Receive Call ==

activate frontB
frontB -> frontB: Show incoming\ncall notification
frontB --> userB: Modal: "User A is calling\nJoin / Decline"
deactivate frontB

userB -> frontB: Click "Join"
activate frontB

frontB -> frontB: Request media permissions:\ngetUserMedia({video, audio})

frontB -> frontB: Local stream obtained

frontB --> userB: Show local video

frontB -> signal: emit("join_call",\n{meeting_id, user_id: userB_id})
activate signal

signal --> frontA: emit("user_joined",\n{user: userB})

deactivate signal
deactivate frontB

== WebRTC Handshake (Offer/Answer) ==

activate frontA

frontA -> frontA: Create RTCPeerConnection\nwith STUN/TURN config

note right of frontA
  RTCPeerConnection config:
  {
    iceServers: [
      {urls: 'stun:stun.l.google.com:19302'},
      {urls: 'turn:...', credential: '...'}
    ]
  }
end note

frontA -> frontA: Add local media tracks\nto peer connection

frontA -> frontA: Create offer (SDP):\nawait pc.createOffer()

frontA -> frontA: Set local description:\nawait pc.setLocalDescription(offer)

frontA -> signal: emit("webrtc_offer",\n{target: userB_id,\noffer: sdp})
activate signal

signal --> frontB: emit("webrtc_offer",\n{from: userA_id, offer: sdp})

deactivate signal
deactivate frontA

activate frontB

frontB -> frontB: Create RTCPeerConnection\nwith same STUN/TURN config

frontB -> frontB: Add local media tracks

frontB -> frontB: Set remote description:\nawait pc.setRemoteDescription(offer)

frontB -> frontB: Create answer (SDP):\nawait pc.createAnswer()

frontB -> frontB: Set local description:\nawait pc.setLocalDescription(answer)

frontB -> signal: emit("webrtc_answer",\n{target: userA_id,\nanswer: sdp})
activate signal

signal --> frontA: emit("webrtc_answer",\n{from: userB_id, answer: sdp})

deactivate signal
deactivate frontB

activate frontA

frontA -> frontA: Set remote description:\nawait pc.setRemoteDescription(answer)

deactivate frontA

== ICE Candidate Exchange ==

note over frontA, frontB
  ICE Gathering happens on both sides simultaneously
  Each side discovers its public IP via STUN
  and exchanges ICE candidates via signaling
end note

frontA -> stun: STUN request
activate stun
stun --> frontA: Public IP discovered
deactivate stun

frontA -> signal: emit("webrtc_ice_candidate",\n{target: userB_id})
activate signal
signal --> frontB: Forward ICE candidate
deactivate signal

frontB -> stun: STUN request
activate stun
stun --> frontB: Public IP discovered
deactivate stun

frontB -> signal: emit("webrtc_ice_candidate",\n{target: userA_id})
activate signal
signal --> frontA: Forward ICE candidate
deactivate signal

note over frontA, frontB
  Both sides add received ICE candidates
  Connection negotiation completes
end note

== WebRTC Connection Established ==

activate frontA
activate frontB

frontA -> frontA: ICE connection state:\nconnected

frontB -> frontB: ICE connection state:\nconnected

note over frontA, frontB
  P2P connection established
  Media streams flowing directly
  between browsers (not via server)
end note

frontA -> frontA: ontrack event fired:\nReceive remote stream

frontA --> userA: Display User B's\nvideo/audio

frontB -> frontB: ontrack event fired:\nReceive remote stream

frontB --> userB: Display User A's\nvideo/audio

deactivate frontA
deactivate frontB

== Call Active - Media Controls ==

userA -> frontA: Toggle microphone mute
activate frontA
frontA -> frontA: audioTrack.enabled = false
frontA -> signal: emit("audio_muted",\n{user: userA_id})
activate signal
signal --> frontB: emit("user_audio_muted",\n{user: userA})
deactivate signal
activate frontB
frontB --> userB: Show "User A muted" indicator
deactivate frontB
deactivate frontA

userB -> frontB: Toggle camera off
activate frontB
frontB -> frontB: videoTrack.enabled = false
frontB -> signal: emit("video_off",\n{user: userB_id})
activate signal
signal --> frontA: emit("user_video_off",\n{user: userB})
deactivate signal
activate frontA
frontA --> userA: Show "User B camera off"
deactivate frontA
deactivate frontB

== Screen Share (Optional) ==

alt User A Shares Screen
    userA -> frontA: Click "Share Screen"
    activate frontA
    
    frontA -> frontA: getDisplayMedia()\n(screen capture API)
    
    frontA -> frontA: Replace video track:\nsender.replaceTrack(screenTrack)
    
    frontA -> signal: emit("screen_share_started")
    activate signal
    signal --> frontB: emit("user_sharing_screen")
    deactivate signal
    
    activate frontB
    frontB --> userB: User A's screen\nreplaces video
    deactivate frontB
    
    deactivate frontA
end

== End Call ==

userA -> frontA: Click "Leave Call"
activate frontA

frontA -> frontA: Close peer connection:\npc.close()

frontA -> frontA: Stop local media tracks:\ntrack.stop() for each track

frontA -> signal: emit("leave_call",\n{meeting_id, user_id: userA_id})
activate signal

signal --> frontB: emit("user_left",\n{user: userA})

signal -> backend: Update meeting\n(async)
activate backend

backend -> db: SELECT COUNT(*)\nFROM active_participants\nWHERE meeting_id = ?
activate db
db --> backend: participant_count
deactivate db

alt Last Participant
    backend -> db: UPDATE meetings\nSET ended_at = NOW(),\nstatus = 'ended',\nduration_minutes = ...\nWHERE id = ?
    activate db
    db --> backend: Success
    deactivate db
end

backend --> signal: Updated
deactivate backend
deactivate signal

frontA --> userA: "Call ended"\nReturn to workspace
deactivate frontA

activate frontB
frontB -> frontB: Remove User A's video
frontB --> userB: "User A left the call"
deactivate frontB

userB -> frontB: Also leaves
activate frontB

frontB -> frontB: Close peer connection

frontB -> signal: emit("leave_call")
activate signal
signal -> backend: Update meeting (ended)
backend -> db: UPDATE meetings
activate db
db --> backend: Success
deactivate db
deactivate backend
deactivate signal

frontB --> userB: Return to workspace
deactivate frontB

== Error Scenarios ==

alt WebRTC Connection Failed
    activate frontA
    frontA -> frontA: ICE connection state:\nfailed
    
    frontA -> stun: Try TURN server\n(relay via server)
    activate stun
    stun --> frontA: TURN relay established
    deactivate stun
    
    note right of frontA
      TURN server relays media
      when P2P fails due to
      strict firewalls/NAT
    end note
    
    frontA --> userA: "Connected via relay\n(higher latency)"
    deactivate frontA
end

alt Network Poor
    activate frontA
    frontA -> frontA: Monitor connection quality:\ngetStats()
    
    frontA -> frontA: Detect high packet loss\nor latency
    
    frontA --> userA: "Poor connection quality"\nSuggest: Turn off video
    deactivate frontA
end

note right of backend
  WebRTC Features:
  - P2P media streaming (low latency)
  - Audio/video/screen sharing
  - Adaptive bitrate (quality adjustment)
  - Echo cancellation, noise suppression
  - Multiple participants (mesh or SFU)
  
  Signaling:
  - Socket.IO for SDP/ICE exchange
  - Not for media (only control)
  
  STUN/TURN:
  - STUN: Discover public IP
  - TURN: Relay when P2P fails
  - Configured per RTCPeerConnection
  
  Meeting Record:
  - Start time, end time, duration
  - Participants list
  - Can be used for attendance
end note

@enduml
